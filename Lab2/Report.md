# Лабораторная работа 2: Работа с коллекциями (Отчет)


## Подход к реализации замеров

Для измерения производительности использовался следующий подход:

1. **Размер коллекций**: 100,000 элементов
2. **Прогрев**: 3 итерации для стабилизации JIT-компиляции
3. **Измерения**: 5 итераций с усреднением результатов
4. **Инструмент**: System.Diagnostics.Stopwatch для точного измерения времени
5. **Операции**:
   - Добавление элементов (в конец, в начало, в середину)
   - Удаление элементов (из начала, из конца, из середины)
   - Поиск элемента по значению
   - Получение элемента по индексу (если применимо)

## Результаты замеров

### Добавление в конец

| Коллекция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|-------------------|----------|-----------|
| List | 0,29 | 0,21 | 0,45 |
| LinkedList | 2,34 | 1,06 | 3,89 |
| ImmutableList | 29,45 | 21,68 | 40,37 |
| Queue (Enqueue) | 0,57 | 0,40 | 1,21 |
| Stack (Push) | 0,37 | 0,30 | 0,51 |
---
### Добавление в начало

| Коллекция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|-------------------|----------|-----------|
| LinkedList | 2,08 | 1,08 | 3,13 |
| ImmutableList | 30,62 | 23,86 | 36,15 |
| List | 267,56 | 264,83 | 271,37 |
---

### Добавление в середину

| Коллекция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|-------------------|----------|-----------|
| LinkedList | 2,10 | 1,07 | 3,27 |
| ImmutableList | 33,70 | 32,14 | 34,89 |
| List | 117,46 | 116,89 | 118,37 |
---

### Удаление из конца

| Коллекция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|-------------------|----------|-----------|
| List | 0,25 | 0,24 | 0,27 |
| Stack (Pop) | 0,59 | 0,54 | 0,66 |
| LinkedList | 3,30 | 2,44 | 4,95 |
| ImmutableList | 23,90 | 23,55 | 24,21 |
---

### Удаление из начала

| Коллекция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|-------------------|----------|-----------|
| Queue (Dequeue) | 0,77 | 0,65 | 1,03 |
| ImmutableList | 13,51 | 13,38 | 13,75 |
| LinkedList | 3,90 | 2,56 | 7,16 |
| List | 269,42 | 265,30 | 274,44 |
---

### Удаление из середины

| Коллекция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|-------------------|----------|-----------|
| ImmutableList | 13,63 | 13,35 | 13,81 |
| List | 120,97 | 118,62 | 122,08 |
| LinkedList | 8188,54 | 8125,45 | 8267,49 |
---

### Поиск элемента

| Коллекция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|-------------------|----------|-----------|
| Queue | 0,07 | 0,07 | 0,07 |
| List | 0,08 | 0,07 | 0,09 |
| LinkedList | 3,96 | 3,88 | 4,01 |
| Stack | 6,54 | 6,43 | 6,65 |
| ImmutableList | 25,52 | 21,06 | 26,73 |
---

### Получение по индексу

| Коллекция | Среднее время (мс) | Мин (мс) | Макс (мс) |
|-----------|-------------------|----------|-----------|
| List | 0,17 | 0,17 | 0,18 |
| ImmutableList | 4,46 | 4,42 | 4,49 |
| LinkedList | 1,43 | 1,42 | 1,46 |    

---
## Анализ результатов

### Добавление элементов

**В конец:**
- Наиболее эффективна: List (0,36 мс)
- List<T> и Queue<T> показывают отличную производительность благодаря внутреннему массиву
- ImmutableList<T> медленнее из-за создания новых экземпляров при каждой операции

**В начало:**
- Наиболее эффективна: LinkedList (2,02 мс)
- LinkedList<T> показывает лучшую производительность (O(1))
- List<T> требует сдвига всех элементов (O(n))

**В середину:**
- Наиболее эффективна: LinkedList (2,13 мс)
- LinkedList<T> эффективнее для вставки в середину
- List<T> и ImmutableList<T> требуют сдвига элементов
---

### Удаление элементов

**Из конца:**
- Наиболее эффективна: List (0,26 мс)
- List<T> и Stack<T> показывают отличную производительность (O(1))
- ImmutableList<T> медленнее из-за создания новых экземпляров

**Из начала:**
- Наиболее эффективна: Queue (0,00 мс)
- Queue<T> и LinkedList<T> показывают лучшую производительность (O(1))
- List<T> требует сдвига всех элементов (O(n))

**Из середины:**
- Наиболее эффективна: LinkedList (0,00 мс)
- LinkedList<T> эффективнее для удаления из середины
- List<T> требует сдвига элементов
---

### Поиск элементов
- Наиболее эффективна: Stack (0,00 мс)
- Все коллекции показывают линейную сложность O(n) для поиска
- List<T> может быть немного быстрее благодаря кэшированию процессора
---

### Получение по индексу
- Наиболее эффективна: List (0,00 мс)
- List<T> и ImmutableList<T> обеспечивают O(1) доступ по индексу
- LinkedList<T> требует последовательного прохода (O(n))
---


### List<T>
**Преимущества:**
- Быстрый доступ по индексу (O(1))
- Эффективное добавление в конец (O(1) амортизированное)
- Хорошая производительность для последовательного доступа
- Низкое потребление памяти

**Недостатки:**
- Медленное добавление/удаление в начале/середине (O(n))
- Требует сдвига элементов при вставке/удалении

**Рекомендации:** Использовать для частого доступа по индексу и добавления в конец
---

### LinkedList<T>
**Преимущества:**
- Быстрое добавление/удаление в начале и конце (O(1))
- Эффективная вставка/удаление в середине (O(1) после нахождения узла)
- Не требует сдвига элементов

**Недостатки:**
- Медленный доступ по индексу (O(n))
- Больше потребление памяти (хранение ссылок)
- Плохая локальность данных (кэш-промахи)

**Рекомендации:** Использовать для частых вставок/удалений в середине, когда доступ по индексу не требуется
---

### Queue<T>
**Преимущества:**
- Оптимизирована для FIFO операций
- Быстрое добавление в конец и удаление из начала (O(1))
- Эффективное использование памяти

**Недостатки:**
- Ограниченный набор операций (только Enqueue/Dequeue)
- Медленный поиск (O(n))
- Нет доступа по индексу

**Рекомендации:** Использовать для реализации очередей, обработки задач в порядке поступления
---

### Stack<T>
**Преимущества:**
- Оптимизирована для LIFO операций
- Быстрое добавление и удаление с одного конца (O(1))
- Эффективное использование памяти

**Недостатки:**
- Ограниченный набор операций (только Push/Pop)
- Медленный поиск (O(n))
- Нет доступа по индексу

**Рекомендации:** Использовать для реализации стека, обхода деревьев, отмены операций
---

### ImmutableList<T>
**Преимущества:**
- Неизменяемость (thread-safe по умолчанию)
- Безопасность в многопоточных сценариях
- Доступ по индексу (O(1))
- Функциональный стиль программирования

**Недостатки:**
- Медленнее всех операций из-за создания новых экземпляров
- Больше потребление памяти
- Сложность O(log n) для большинства операций

**Рекомендации:** Использовать в многопоточных приложениях, функциональном программировании, когда неизменяемость критична
---

## Общие рекомендации

1. **Для частого доступа по индексу и добавления в конец**: используйте `List<T>`
2. **Для частых вставок/удалений в середине**: используйте `LinkedList<T>`
3. **Для очередей (FIFO)**: используйте `Queue<T>`
4. **Для стеков (LIFO)**: используйте `Stack<T>`
5. **Для многопоточности и неизменяемости**: используйте `ImmutableList<T>`
6. **Избегайте LinkedList<T> для доступа по индексу** - используйте List<T>
7. **Избегайте ImmutableList<T> для частых изменений** - используйте обычные коллекции
---
